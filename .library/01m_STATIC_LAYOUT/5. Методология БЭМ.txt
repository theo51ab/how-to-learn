===== Методология БЭМ
...
Официальная документация БЭМ: https://ru.bem.info
...

:::: БЛОКИ

Блок — самостоятельная единица. Его можно вырвать из контекста и использовать в другой части сайта. Одни блоки могут быть вложены в другие, но при этом каждый вложенный блок может существовать самостоятельно.
...
Располагайте блок так, чтобы он никак не влиял на окружение. Главная «фишка» блока в том, что его можно использовать повторно. Поэтому не задавайте блоку свойств, влияющих на другие DOM-элементы. Не задавайте блоку внешних отступов и позиционирования — иначе в новом контексте все эти свойства придётся переопределять.
...
Блок везде выглядит одинаково. Поэтому стили блока должны быть независимыми от окружающих и родительских блоков. CSS-селектор блока всегда пишут по его имени, то есть по названию класса. И поскольку блок обладает уникальным именем, стили, прописанные для него, никак не затронут другие фрагменты страницы.
/*не по БЭМ*/
.logo {
  margin: 20px;
  position: absolute;
  left: 10px;
}
/*по БЭМ*/
.logo {
  padding: 20px;
  position: relative; /* не влияет на позицию блока, если не указано смещение */
}
...
По БЭМ можно стилизовать фрагменты только по именам классов. Название тегов, идентификаторы или любые другие признаки нельзя использовать для селекторов. Это одна из технических основ стандарта.
...
Опишите блоки в вёрстке подходящими элементами: div, nav, section, header, footer. Блок — это не всегда контейнер. Блоком могут выступать заголовки, абзацы, поля форм, кнопки и вообще любые элементы, если они созданы для многоразового использования. Дайте каждому блоку имя и запишите его в свойство class. В БЭМ стили прописывают именно селекторам классов, а имена тегов и идентификаторы не используют.
...
Согласно спецификации БЭМ, нельзя подключать файлы normalize.css и reset.css: они влияют на внешний вид всей страницы, а стили каждого блока должны быть независимы. Тем не менее, разработчики часто подключают эти файлы к своим проектам, если в этом есть практическая польза.

:::: ЭЛЕМЕНТЫ

Элемент — это составная часть блока, которую нельзя создавать и использовать в отрыве от блока.
  <header class="header"> <!-- это блок, «шапка» страницы -->
    <a href="#" class="header__link">[Ваше имя]</a>
  </header>
Компонент с классом header__link — это элемент, ссылка внутри шапки. Такая ссылка должна быть только в шапке и нигде более.
...
БЭМ рекомендует именовать классы так, чтобы сразу было ясно, что это за компонент — элемент или блок. Рекомендации такие:
- Название класса блока — слово или несколько слов, разделённых дефисом.
- Элементы именуют так: сначала пишут название блока, к которому относится элемент, потом два нижних подчёркивания __, и затем — имя элемента. Если название элемента состоит из двух слов, вместо пробелов ставят дефис.
...
Для стилизации элементов используют только селекторы классов. Так же, как и для стилизации блоков.
...
Имя элемента описывает содержание, а не внешний вид или состояние: main-content__text — хорошее имя, main-content__red — плохое.
...
Блок может не содержать элементов. Но если элементы нужны, они всегда являются частью блока.

:::: МОДИФИКАТОРЫ

Модификаторы — это не фрагменты страницы. Модификаторы определяют состояние и поведение блоков или элементов.
...
Название класса модификатора составляют так: сначала идёт имя блока или элемента, за ним — имя модификатора через нижнее подчёркивание:
- для модификатора блока: блок_модификатор.
- для модификатора элемента: блок__элемент_модификатор.
...
Модификаторы делятся на два типа — булевы и вида «ключ-значение».
.
Булевы модификаторы используют, когда у элемента или блока может быть только два состояния. Например, у пункта меню может быть два состояния: обычное и активное (если пользователь находится на странице этого пункта меню). Обычное состояние описывают стилями элемента menu__link, а активное состояние — модификатором menu__link_active.
  <nav class="menu">
    <a href="index.html" class="menu__link menu__link_active">Главная</a>
    <a href="about.html" class="menu__link">О нас</a>
    <a href="contacts.html" class="menu__link">Контакты</a>
  </nav>
.
Модификаторы «ключ-значение» показывают различные варианты внешнего вида, состояния или поведения.
Блок с результатом решения задачи может вести себя по-разному: сообщать статус успешного прохождения, сообщать об ошибке или содержать дополнительное сообщение. Эти три модификатора связаны одним ключом — типом сообщения, но с разными значениями.
  <div class="solution-status solution-status_type_success"></div>
  <div class="solution-status solution-status_type_error"></div>
  <div class="solution-status solution-status_type_message"></div>
.
Запомните разницу в записи модификаторов:
- булевый: блок__элемент_модификатор или блок_модификатор.
- ключ-значение: блок__элемент_ключ_значение или блок_ключ_значение.
.
Если на странице у элемента всего два состояния, но потенциально их может стать больше — используйте модификаторы вида ключ-значение.
...
// Зачем мы плодим классы? Пока не ясно, но скоро код так упростится, то перестанет нравиться прошлый. Такое улучшение кода называют рефакторингом.

:::: СПОСОБЫ МОДИФИКАЦИИ

БЭМ построен вокруг идеи создания независимых блоков, которые можно использовать повторно. Но редко можно встретить интерфейс, в котором ни один блок не меняет своих размеров или расположения в разных контекстах. Посмотрите, как сделана шапка на сайте Авито. При прокрутке страницы с поиском, шапка следует за пользователем. Но если открыть страницу товара, шапка остаётся прижата к верхней части сайта.
.
Описывать такое поведение на уровне блока не выйдет — нужен другой подход. Ещё один распространённый случай — блок с иконками социальных сетей. В подвале его могут разместить слева, а в блоке с контактами — справа. Или наоборот.
.
В общем, разработчикам постоянно требуется изменить внешний вид блока в каком-то контексте или дополнить его поведение. Есть два способа сделать это, и один из них вам уже знаком — использовать модификатор блока.
.
Использование модификатора :
Модификаторы используют, чтобы изменить один конкретный экземпляр блока. Хороший пример — модификатор, который меняет цвет текста с темного на светлый при тёмном фоне страницы. Установка и снятие модификатора должны изменять только сам блок и не влиять на его окружение — другие блоки.
.
Когда модификаторы не подойдут :
.
Модификаторы не всегда подходят для расположения элементов. Технически их можно использовать, но код становится менее понятным, потому что модификатор не сообщает контекста.
Например, мы делаем интернет-журнал. Все картинки на сайте мы обрамили рамкой, добавили небольшую тень:
.picture {
    border: 1px solid grey;
    box-shadow: 0 0 3px grey;
} 
Допустим, картинки внутри статей нужно расположить по центру. В принципе мы можем применить для этого модификатор:
.picture_pos_centered {
    margin: auto;
}
/* Но не стоит так делать */ 
При таком подходе модификатор не сообщает контекста, в котором расположен блок. Модификатор говорит лишь «это стили картинки, расположенной по центру». А полезнее было бы знать «это стили картинки, находящейся в зоне контента».
.
Модификатор также не годится для стилизации однотипных элементов, расположенных в разных блоках. Например, мы верстаем шапку сайта и хотим активные ссылки окрасить в жёлтый. Для этого создаём модификатор:
.header__link_active {
    color: yellow;
} 
Затем мы хотим окрасить в жёлтый цвет ссылки в контенте. И тут модификатор нам не поможет. Имя модификатора связано с именем блока, поэтому мы не можем добавить одному блоку модификатор другого.
<div class="content">
    <!-- так делать нельзя -->
    <a class="content__link header__link_active">
    </a>
</div> 
Поэтому для позиционирования и стилизации однотипных элементов модификаторы не годятся. Для этих целей лучше подходят «миксы».
.
Микс: смешивание стилей
Микс — это смешение стилей двух блоков. В этом случае мы задаём одному блоку два имени и получаем в результате новый блок, который обладает свойствами двух смешанных блоков.
.
Микс можно сделать двумя способами.
.
Микс для общих правил
Первый способ предназначен для того, чтобы определить общие правила для разных блоков. Очень распространённая задача — задать разным блокам одинаковые стили текста и шрифта. Для этого мы стилизуем сразу несколько блоков:
<nav class="menu"></nav>
<section class="content"></section>
<footer class="footer"></footer> 
Мы хотим задать блокам content и footer одинаковые текстовые свойства. Для этого создадим новый селектор и опишем в нём, как должен выглядеть текст. А затем добавим этот класс всем блокам, где хотим видеть такой текст.
Создадим БЭМ-блок main-text и стилизуем его:
.main-text {
    color: #000;
    font-family: 'Arial', 'Helvetica', sans-serif;
    font-size: 18px;
    line-height: 1.5;
    font-weight: normal;
} 
И примешаем созданный блок к нужным блокам. Это и называется «сделать микс»:
<nav class="menu"></nav>
<section class="content main-text"></section>
<footer class="footer main-text"></footer> 
Нужным блокам присвоены нужные стили. Мы произвели микс на уровне классов и тем самым стилизовали группу блоков.
.
Примешивание элемента блоку
Вернёмся к примеру с иконками социальных сетей. Их часто размещают в подвале сайта. Например, такой блок может располагаться по центру подвала. Таким образом, блок социальных сетей нужно сдвинуть внутри подвала свойством margin.
<footer class="footer">
    <div class="social-icons"></div>
</footer> 
Согласно БЭМ описывать внешние отступы для блока не рекомендуется. Но нам нужно задать соцсетям margin: 50px auto;.
Хорошая идея — подмешать к стилям блока social-icons класс БЭМ-элемента, который относится к родительскому блоку:
<div class="footer">
    <div class="social-icons footer__social-icons"></div>
</div> 
Блок social-icons теперь представляет собой одновременно и самостоятельный блок, и элемент блока footer по имени footer__social-icons.
Так мы можем уточнить поведение нужного блока, сохранив его независимость: ведь margin мы указываем не для блока, а для элемента.
.footer__social-icons {
    margin: 50px auto;
} 
Все эти миксы могут казаться сложными поначалу. Но со временем вы наберётесь опыта в именовании селекторов и модифицировании блоков и элементов.

====== Приведём в порядок код
В прошлых уроках мы говорили про БЭМ. Одним из основных требований этого стандарта является использование исключительно селекторов классов. Согласно БЭМ нельзя использовать селекторы по тегам.

Но БЭМ-правила не единственные. Есть дополнительные правила, которых следует придерживаться при написании кода.

Одно из таких правил вы уже знаете и, мы надеемся, применяете. Это использование табуляции для сдвига вложенных элементов вправо в коде.

Ещё одно важное правило касается порядка записи CSS-селекторов. Браузер читает CSS-код сверху вниз и применяет только после того, как дочитает все стили до конца. Поэтому правила, описанные в коде ниже, имеют приоритет перед теми, что описаны выше.
.menu {
    background-color: #fff;
}
/* styles */
.menu {
    background-color: #000; /* этот селектор более приоритетный, потому что находится ниже в коде*/
} 
Технически в этом примере нет ошибки, но явно видна небрежность разработчика. В результате у блока menu будет чёрный фон: именно это правило написано последним.

Старайтесь писать селекторы в том же порядке, в каком они расположены в HTML-коде: не стоит размещать стили для footer выше стилей для header.

Придерживайтесь примерно такого порядка:
- Напишите самые общие правила. Например, для body. Но не забудьте, что даже к уникальным тегам следует обращаться по селектору класса.
- Затем напишите стили вспомогательных блоков — например, тех, которые вы используете только для микса.
- После этого записывайте первый блок, встретившийся в HTML.
- Потом его модификатор, если он есть.
- Затем первый элемент этого блока.
- Затем модификаторы этого элемента.
Таким же образом описывайте в CSS все блоки, читая HTML-код сверху вниз.

===== Закрепим навык разметки и понимание семантики

Пока непонятно, что содержит в себе каждая флекс-строка. Чтобы это исправить, добавим строкам подзаголовки. Но если установить их внутри флекс-контейнера, подзаголовки станут флекс-элементом и расположатся в линию.

К тому же, размещать заголовки внутри блока списка семантически некорректно. Правильнее создать обёртки тегом section. Именно секциями размечают озаглавленные зоны.

===== Заключение

Вы познакомились с БЭМ — самой популярной методологией именования классов. БЭМ — это не только про классы, это про компонентный подход к интерфейсу. Во многих командах БЭМ модифицируют, применяют частично, в общем — это не панацея. Но понимание БЭМ в его классическом варианте выстраивает правильный подход к мышлению об интерфейсе, а значит и к его реализации.

Многим студентам БЭМ заходит сложно, мы знаем это, но для правильной ментальной картины нужны методологии, доказавшие свою ценность. А БЭМ в этом плане очень надёжен.

Что еще почитать?

БЭМ-методология: с чего всё начиналось и зачем всё это нужно (на русском).
https://habr.com/company/yandex/blog/276035/

Сайт о БЭМ-методологии. Если что-то забыли — вам сюда (на русском).
https://ru.bem.info/methodology/key-concepts/

Подробнее о семантике — если хотите совсем заморочиться (на английском).
http://nicolasgallagher.com/about-html-semantics-front-end-architecture/

Статья о «псевдоэлементах в псевдоэлементах, псевдоэлементах с псевдоклассами и других невозможных вещах» (на русском).
https://css-live.ru/articles-css/impossible-pseudos.html

===== Что можно сделать в проекте?
Посмотрите на бриф. Все элементы там описаны в терминах блоков, элементов и модификаторов. Попробуйте построить систему классов проекта. Начните с малого, например, с секции description: выделите в ней блок и его элементы. А после двигайтесь к более сложным секциям.
Можете проделать упражнение и вынести все имена классов из брифа в отдельный документ. Это поможет быстрее вносить имена классов в код и ничего не потерять.