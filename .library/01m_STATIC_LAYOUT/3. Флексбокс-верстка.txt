Преобразование во флекс-контейнер

До сих пор мы верстали поток элементов. Те, что идут в HTML-коде первыми, всегда выше либо левее вторых. Если вы делаете новостной или продуктовый сайт, так не годится. Свежие новости и товары должны стоять выше. Вам также нужна свобода перестроения из ряда в колонку на узком экране мобильного телефона, свобода выравнивания всех элементов по краю или центру — вам вообще нужно больше свободы. Её даёт одна строчка CSS-кода:

display: flex;

Это приказ браузеру: отображать элемент с таким свойством как гибкий блок. По английски — “flexible box“, или сокращённо — “flexbox“. Мы будем писать кириллицей: флексбокс или флекс.

Если вы забыли о свойстве display, перечитайте теорию в уроке по ссылке внизу. В вёрстке понимание этого свойства делает вас уверенным. Вы будете задавать свойство display постоянно, нужно делать это осмысленно.
https://praktikum.yandex.ru/trainer/web-plus/lesson/7d4aa538-dbec-476b-a167-3b8b3455fd6c/task/6b95e817-d94a-4f30-b8b6-930affebb68b/
::::
Что делать, когда блоки с определенными размерами должны следовать друг за другом по горизонтали и не занимать всю строку? Можно задать элементам комбинированный тип — блочно-строчный. С одной стороны, они не занимают собой всю горизонталь, с другой, восприимчивы к указанию размеров через CSS. Например, так ведут себя элементы img.
/* display по-английски «отображение» */
display: block; /* сделает элемент блочным */
display: inline; /* сделает элемент строчным */
display: inline-block; /* сделает элемент блочно-строчным *
////

Свойство display: flex; превращает элемент во флекс-контейнер (англ. flex container), а вложенные в него дочерние — во флекс-элементы (англ. flex items). Контейнер поступает со своими элементами как тренер с футболистами: размещает их по определённой схеме и прописывает поведение в меняющейся обстановке. В свою очередь игроки, то есть флекс-элементы, могут проявить инициативу, показав личные свойства: они меняются местами и сами выбирают себе длину маршрута. Всё это мы сейчас изучим.

Начнём с простого. В контейнере один дочерний элемент с единственным свойством margin: auto;
Флекс-контейнер управляет не элементом, а пустотой вокруг него. Если свойство содержит уточнение — например, margin-left: auto; — вся пустота оказывается слева, а элемент прижимается к правому краю контейнера.

А margin: auto; оказывает совершенно магическое действие. Пустота равномерно окружает элемент, и он оказывается точно посреди своего контейнера как по ширине, так и по высоте. Безо всякого свойства vertical-align. И это только начало!

код примера HTML:
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="https://code.s3.yandex.net/web-code/normalize.css">
  <link rel="stylesheet" href="style.css">
  <title>Портфолио</title>
</head>
<body>
  <div class="header">
     <a class="header-link" href="#" target="_blank">Яндекс Практикум</a>
  </div>
</body>
</html>

код примера CSS:
div {
  border: 1px solid red;
}

.header {
  height: 95px;
  display: flex;
}

.header-link {
  margin: auto;
}

===== Флекс-контейнер с несколькими элементами

Когда во флекс-контейнере несколько элементов, они сразу же выстраиваются в строку независимо от типа. Нет надобности переводить их значением inline-block в строчно-блочные. Поскольку возможности флексбокс-вёрстки на этом только начинаются, её охотнее используют для построения макетов, чем inline-block.
//HTML
<body>
  <div class="header">
     <a class="header-link" href="#" target="_blank">Яндекс Практикум</a>
  </div>
  <div class="flex-row">
    <div class="project project_beginner project_music-album">
      
    </div>
    <div class="project project_beginner project_design-principles">
      
    </div>
  </div>
</body>

//CSS
div {
  border: 1px solid red;
}

.header {
  height: 95px;
  display: flex;
}

.header-link {
  margin: auto;
}

.flex-row {
  display: flex;
  /*Изображения растягиваются и сжимаются, адаптируясь к новым условиям. Они продолжают заполнять собой весь флекс-контейнер.*/
}

.project {
  background-position: center;
  background-size: cover;
}

.project_beginner {
  width: 636px;
  height: 430px;
}

.project_music-album {
  background-image: url('https://code.s3.yandex.net/web-code/album.png');
}

.project_design-principles {
  background-image: url('https://code.s3.yandex.net/web-code/design.png');
}
^^^^ каждый элемент получил два класса. Один общий со стилями всех проектов. Второй - особенный для проектов начального уровня. Именно так правильно задавать стили.

===== Терминология флекса

Терминология флексбокса — это описание свойств для элементов двух типов:
- флекс-контейнер — родительский элемент: гибкое пространство, в котором элементы распределяются по правилам, установленным для контейнера;
- флекс-элементы — дочерние элементы флекс-контейнера; подчиняются правилам, описанным как для контейнера, так и для отдельных элементов персонально.

Верстальщики обычно применяют универсальные классы, которые описывают флекс-контейнер с нужными параметрами. То есть создают класс с единственным свойством. И затем назначают этот класс всем элементам, которым это свойство нужно.

В предыдущем уроке вы уже создали универсальный класс — flex-row. Это просто строка, в которой элементы ведут себя по законам флекса. Поэтому где бы нам ни понадобился флекс-контейнер, мы просто зададим элементу класс flex-row. Флекс - это всегда строки и колонки, поэтому вам часто встретятся классы с именами, заканчивающимися -row или -column.

Для размещения видео есть тег <video>.
<video class="project-video" src="https://code.s3.yandex.net/web-code/procrastinate.mov" autoplay muted loop></video>

https://betacode.net/12475/html-video
К сожалению, в CSS видео нельзя сделать фоном. Зато можно растянуть дочерний элемент на всю ширину и высоту родителя. Это будет выглядеть похоже на фон.
Для этого задайте элементу с классом project-video CSS-свойства:
width: 100%;
height: 100%;
object-fit: cover; 
Свойство object-fit подстроит элемент под размер так, чтобы он закрывал определенную площадь. Её задают параметрами width и height. Их нужно указать явно, в нашем случае — это 100% ширины и высоты родителя.
Так можно делать и с видео, и с изображениями. Свойство полезное.

===== Вложенные флекс-контейнеры

Вложенный во флекс-контейнер элемент может сам стать флекс-контейнером. Так он сможет распоряжаться вложенными в него элементами. Заметим, что флекс-элементы подчиняются только своему «непосредственному начальнику» (родителю) — настройки флекс-контейнеров более высокого уровня до них не доходят.

::::
В блок поместите код видео:
<video class="project-video" src="https://code.s3.yandex.net/web-code/like.mp4" autoplay muted loop></video> 
Для класса project-video вы уже определили свойство object-fit. Поэтому видео красиво растянется на весь блок.
::::

===== Направление внутри флекс-контейнера

По умолчанию флекс-элементы внутри контейнера отображаются в ряд слева направо в том порядке, в каком они прописаны в коде HTML-документа. Они следуют направлению потока. Флексбокс-вёрстка позволяет преобразовать ряд в колонку и обратить порядок следования, направив его против потока. Для этого контейнеру придают свойство flex-direction (англ. direction, «направление»). Его возможные значения:
- flex-direction: row; — обычный ряд (англ. row, «ряд»), элементы следуют в потоке, слева направо. Это значение по умолчанию, его можно и не прописывать.
- flex-direction: row-reverse; — ряд в обратном порядке (англ. reverse, «обратный ход»).
- flex-direction: column; — колонка (англ. column, «столбец») в обычном порядке. Очень пригождается при адаптации под мобильные устройства.
- flex-direction: column-reverse; — колонка в обратном порядке.

===== Управление положением содержимого флекс-контейнера

В предыдущем уроке мы рассказывали, как распределить флекс-элементы. Но сколько бы их ни было, остаётся ещё пустое пространство. Его тоже нужно распределять. В этом уроке расскажем, как это делать.
Это делается в двух направлениях — вдоль оси, по которой расставлены элементы (т.е. вдоль строки/колонки), и поперёк. Регулировка вдоль строки либо колонки задаётся свойством justify-content. Название пришло из механики, где юстировку начинают с выравнивания деталей вдоль главной оси конструкции (например, объектива).

Возможные значения свойства justify-content:
- flex-start: сначала идут флекс-элементы, за ними — оставшееся пустое пространство. Если значение flex-direction — row, все флекс-элементы прижмутся к левому краю контейнера. А справа окажется пустота.
Если flex-direction: column, элементы идут сверху вниз. И свойство justify-content: flex-start соберёт флекс-элементы сверху, а пустое пространство окажется снизу.
justify-content: flex-start — это значение по умолчанию.
- flex-end: сначала идёт пустое пространство, а к концу контейнера прижаты элементы. При flex-direction: row, элементы окажутся справа, а всё пустое пространство — слева. При flex-direction: row-reverse — наоборот.
- center: флекс-элементы собраны посередине, а пустое пространство распределено поровну с двух сторон от них.
- space-between: первый элемент прижат к началу контейнера, последний — к концу, а остальные расставлены между ними с одинаковыми промежутками. Подходит для меню, растянутого во всю ширину страницы.
- space-around: всё пустое пространство делится на равные промежутки. Каждый флекс-элемент получает отступы по обе стороны, равные этому промежутку. Так между флекс-элементами оказывается отступ в 2 промежутка, а перед первым и после последнего элементов — в 1 промежуток.
- space-evenly: все отступы равной величины. И между элементами, и между границами контейнера и первым и последним элементами.

===== Выравнивание флекс-элементов в контейнере

В предыдущих уроках мы разобрались с порядком элементов во флекс-контейнере. Также мы рассказали, как управлять пустым пространством вокруг них. Теперь возьмёмся за выравнивание.

Когда флекс-элементы разной высоты выстроены в ряд, или столбец составлен из элементов разной ширины, их также можно выровнять по определённой линии. Предназначенное для этого свойство так и называется align-items, в переводе с английского «выровнять элементы по линии». Эта линия проходит вдоль направления перечисления элементов. Так, если flex-direction задаёт расстановку в ряд, то линией может быть верхний край контейнера, нижний край, центральная ось и так называемая базовая линия — граница, где первый элемент разделяется на две части (например, на текст и картинку).

Возможные значения свойства align-items:
- stretch («растянуть») — установлено по умолчанию. Вместо выравнивания элементы растянуты от одного края контейнера до другого: в ряду сверху донизу, в колонке справа налево. Значение stretch стало большим достижением флексбокс-вёрстки. Оно позволяет придать всем элементам одинаковый размер, не прибегая к определению ширины и высоты.
- flex-start (по началу флекс-контейнера) — когда направление контейнера row или row-reverse, все элементы прижаты к верхнему краю контейнера, а при значениях column или column-reverse — к левому.
- flex-end (по концу флекс-контейнера) — когда направление контейнера row или row-reverse, все элементы прижаты к нижнему краю контейнера, а при значениях column или column-reverse — к правому.
- center («центрировать») — центральная ось контейнера делит каждый элемент пополам.
- baseline («по базовой линии») — базовые линии всех флекс-элементов становятся продолжением базовой линии первого по порядку.

Частая ошибка — задавать свойство height вместо min-height. Мы устанавливаем именно минимальную высоту, чтобы контейнер растягивался, когда ссылки встанут в колонку: например, на телефоне. Запомните этот приём с min-height. Прежде чем установить элементу фиксированную высоту, задайте себе вопрос: «Что если контента станет больше?».

Класс project_vanilla называется так потому, что “vanilla“ — это сленговое название «чистого» языка программирования. То есть самогó языка без сторонних библиотек и фреймворков. На русском жаргоне так тоже говорят: «Написать сайт на „ванильном“ JS». Сайт-шутка про ванильный фреймфорк: http://vanilla-js.com/.

===== Перенос элементов при сжатии окна браузера

По умолчанию флекс-контейнер делает окно "резиновым": при сжатии или расширении окна просмотра браузера отдельные флекс-элементы автоматически настраивают свою ширину или высоту так, чтобы поместиться в контейнер.

Это поведение можно изменить так, чтобы при сжатии элементы переносились на новую строку или колонку.
Для этого свойству flex-wrap задают значение wrap (англ. wrap, «завернуться»). У флекс-контейнера с таким свойством последние элементы заворачиваются (переходят) на новую строчку, если не умещаются на текущей.
Значение wrap-reverse («перенос наоборот») позволяет устроить так, чтобы переносились не последние, а первые элементы строки/колонки.

Свойство flex-wrap есть у флекс-контейнера всегда, только по умолчанию ему задано значение nowrap, запрещающее перенос.

Порядок переноса элементов зависит от направления оси флекс-контейнера. При значении flex-direcrion: row первым перенесется на новую строку самый правый элемент, а при flex-direction: row-reverse - наоборот, левый. Для возможности переноса в второй, третий и далее ряд как раз и важно устанавливать минимальную высоту, а не фиксированную.

===== Свойства флекс-элементов. Порядок

Вот заданы главные настройки флекс-контейнера: порядок отображения, распределение пустот и правила переноса элементов. Это похоже на тренерские указания команде футболистов, которые получили схему игры на разные случаи.

Пора перейти к собственным возможностям «игроков», т.е. персональным свойствам отдельных элементов.
Так, футболисты, не нарушая схему своего наставника, могут меняться местами и ролями: центральный полузащитник может стать правым.

Во флексбокс-вёрстке такое можно проделывать, не трогая ни HTML-код, ни CSS-правило для контейнера. В правила тех флекс-элементов, чей порядок следования нужно переопределить, вводится свойство order.
Элемент, которому задано CSS-свойство order: 1; будет показан раньше элемента со свойством order: 2; (здесь могут быть любые целые числа, лишь бы одно из них было меньше другого).

Элемент с отрицательным значением порядка (order: -1;) будет первым в контейнере, если у других элементов значения положительны или даже не заданы («капитан команды»). Весьма удобно для главной новости на сайте или меню.

И наоборот, если порядок с положительным значением задан одному-единственному элементу, тот закрепляется на последнем месте («вратарь»).

===== Свойства флекс-элементов. Выравнивание отдельного элемента

Заданное флекс-контейнеру свойство align-items применяется ко всем элементам сразу. Иногда нужно, чтобы отдельный элемент не подчинялся общему правилу. На помощь приходит свойство align-self (по-английски примерный смысл этого словосочетания — «равняться на себя»). Оно применяется непосредственно для уникального флекс-элемента и принимает те же значения, что и align-items:
- flex-start,
- flex-end,
- center,
- baseline,
- stretch.
Так футболист может выбиться из общей схемы, взяв на себя дополнительную роль. Например, если команда играет в меньшинстве. Это указание не всей сборной, а только ему лично.

===== Свойства флекс-элементов. Базовая ширина элемента

Иногда необходимо, чтобы один флекс-элемент имел определённый размер, пока другие свойства флекс-контейнера не начнут его сжимать или расширять. Для этого есть свойство flex-basis (от англ. «базис», базовый размер флекс-элемента). Значение задаётся в пикселях. Это ширина, если флекс-элементы отображаются в ряд, и высота — если в колонку.

::::
Найдите в вёрстке элемент с классом menu. Сразу после него создайте div с классом main. Поместите в этот новый div все остальные элементы, кроме элементов с классами header, menu и footer. Так все блоки с классом flex-row со своим содержимым станут дочерними для блока с классом main.
::::

Всё, что надёжно работает и непременно пригодится в повседневной работе, известно вам уже сейчас. В конце урока вы найдете дополнительную информацию. В ней будут свойства, которым не нашлось места в этом макете.

===== Что мы еще не сказали о флекс?

У флексбокса довольно большая спецификация со множеством тонкостей. Мы разобрали самые необходимые свойства — те, что пригождаются чаще всего. Но осталось несколько деталей. Для новичка они тяжеловаты, но необходимы при создании адаптивности.

Мы постарались соблюсти баланс: рассказать об этих деталях, но и не перегружать вас. Самое важное — понять, как работают флекс-свойства, описанные в этом уроке. А когда эти свойства понадобятся, вы сможете найти информацию в интернете.

Ещё о флекс-контейнере

Есть свойство align-content. Оно отвечает за то, как поведут себя элементы при переносе на новую строку или колонку при включённом flex-wrap. Когда одна строка заполнена, где должна оказаться следующая: у другого края контейнера? По центру? Прямо рядом c предыдущей строкой? За это и отвечает свойство align-content.

Свойство align-content похоже на justify-content. Но justify-content отвечает за расположение элементов вдоль оси флекс-контейнера, а align-content — поперёк этой оси при переносе. То есть вдоль «поперечной» оси флекс-контейнера.

Без включённого flex-wrap: wrap; свойство align-content работать не будет вовсе.

При значении align-content: flex-start; блоки выстраиваются от начала поперечной оси флекс-контейнера. Сначала заполняется самая верхняя строчка контейнера — та, что находится у начала поперечной оси. Когда на первой строке места не остаётся, элементы переносятся на следующую строку. При этом элементы стараются располагаться как можно ближе к началу поперечной оси флекс-контейнера — то есть к верху.

В случае, когда align-content: flex-end;, блоки ведут себя похожим образом, но прижимаются к концу поперечной оси — к низу блока. Поэтому сначала заполняется нижняя строчка. Когда места не остаётся, заполняется вторая строчка снизу. И так далее.

Значение align-content: center; заставляет элементы выравниваться относительно центра поперечной оси.
Если установить align-content: space-around;, всё свободное пространство поделится на равные промежутки. Эти промежутки добавятся флекс-элементам сверху и снизу.

Значение align-content: space-between; старается разместить элементы так, чтобы между ними были равные отступы. Такие же отступы соблюдаются между элементами и границами флекс-контейнера.

Последнее значение свойства align-content — это stretch. Оно растягивает элементы так, чтобы они занимали всю поперечную ось флекс-контейнера.

Обратите внимание: мы использовали в описании понятия «верх» и «низ». Эти понятия удобны, потому что интуитивно понятны. Но помните: поведение элементов зависит от направления осей флекс-контейнера.

Ещё про флекс-элементы

У элементов есть достаточно экзотические свойства flex-grow и flex-shrink. Эти свойства отвечают за распределение пространства, отведённого элементу в случаях, когда пространство родителя больше, чем нужно элементам (это flex-grow) или меньше (это flex-shrink).

Сначала расскажем про flex-grow и вспомним немного школьной математики. Когда элементы занимают не весь контейнер, остаётся свободное пространство. Это пространство можно распределить — «отдать» элементам в разных пропорциях. Например, 5/10 прибавить к первому элементу, 3/10 ко второму и 2/10 к третьему. В этом случае каждому элементу указывают flex-grow, равный числителю этих дробей: 5-ти, 3-м или 2-м.

Обратите внимание, что пропорционально распределяется именно оставшееся пространство, а не пространство всего контейнера.

Если вы любите формулы — вот перевод хорошей статьи про flex-grow:
https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-flex-grow-%D0%B2-css-%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-557d406be844

Flex-shrink работает по обратному принципу. Если элементы не умещаются в контейнер, браузер считает, сколько места не хватает. Далее он высчитывает, насколько нужно уменьшить элемент, ориентируясь на недостаток места, размер и общий вес элементов. Понять математику и увидеть формулы можно в статье-продолжении.
https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-flex-shrink-%D0%B2-css-%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D0%B5-%D1%80%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE-c41e40767194

===== Заключение

Поздравляем, флексбокс изучен! Вы научились располагать элементы в одном из четырех направлений: слева направо, справа налево, сверху вниз или снизу вверх. Знаете, как менять порядок элементов, не трогая разметку, автоматически задавать отступы и размеры элементов, чтобы уместить их в доступное пространство. Как задать перенос элементов внутри контейнера, выровнять их и по горизонтали, и по вертикали.

А значит, вы можете выстраивать сетки страниц любых сайтов.

Мы многое рассказали о флексбоксе, но это ещё не всё. Флексбокс постоянно дорабатывают и улучшают. Надёжнее всего отслеживать изменения по документации флексбокса.
https://www.w3.org/TR/css-flexbox-1/

Также прокачаться во флексах помогут источники:

- Статья, в которой кратко и наглядно показано, как работает флексбокс;
https://habr.com/ru/post/467049/
- Игра, которая поможет быстрее запомнить свойства флексбокса. Нужно помогать лягушонку писать CSS-код;
http://flexboxfroggy.com/#ru
- Статья о неочевидных тонкостях флексбокса;
https://habr.com/ru/post/329820/
- Гифками показано как работают флекс-свойства;
https://tproger.ru/translations/how-css-flexbox-works/
- Интерактивная демонстрация флекс-свойств.
https://codepen.io/justd/full/yydezN/

В этой теме вы сделали сайт-портфолио, в следующих — будете его улучшать. Вы научитесь писать код, понятный другим разработчикам и роботам. А также научитесь менять поведение элементов при наведении мыши, что сделает ваш сайт интерактивнее.

===== Что можно сделать с проектом?

Попрбуйте сверстать на флексах по очереди такие секции. Размеры берите из брифа, а имена классов пока придумайте сами. Дальше мы объясним, что такое блок, элемент и модификатор.

Начните с этой секции: "Главные проблемы в обучении"
После оформите такую секцию: "86 миллиардов"
Потом перейдите к этой секции: "1-10 методы"

Постарайтесь использовать общие с предыдущей таблицей стили. Новые применяйте, только чтобы подчеркнуть особенности поведения: изменение цвета текста или фона.

В дальнейшем вы сильно измените этот код, зато теперь у вас есть задел на будущее.