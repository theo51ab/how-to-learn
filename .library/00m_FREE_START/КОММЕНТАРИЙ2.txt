====================
БОЛЬШЕ CSS
====================
===== НОВАЯ СЕКЦИЯ

Схема сайта станет такой:
—> входной экран header
—> начало секции для контента
    —>—> карточки внутри секции
—> конец секции для контента 

Для создания секций и разделов применяют элемент section. Он ведёт себя как div, но сразу сообщает браузеру о своём предназначении — это позволит поисковикам качественнее прочитать ваш сайт.
Сразу после элемента header создайте пустой элемент section.

===== КЛАССЫ

Теперь представьте: нужно не два, а десять разных div. Тогда селектор div {} навяжет полупрозрачный серый фон всем десяти, пресекая любой индивидуализм.
На выручку приходят атрибуты class. Классы задают каждому элементу именной ярлык. Так, <div class="card"></div> позволит обращаться в стилях к элементу card, не затрагивая свойства других div.
Один и тот же класс можно присвоить любому количеству элементов. Например, класс white-text — всем элементам с текстом белого цвета.

<h1 class="white-text">Откуда к нам пришла зима</h1>
<p class="white-text">Не знаешь ты, никто не знает</p>
<!-- в html название класса указывается в кавычках атрибута class --> 

Текст будет белым, если в стилях прописано правило для класса:
.white-text { 
    color: #fff; 
} 
/* в стилях селектор класса начинается с точки */

Только элементы с классом white-text получат белый текст.
Имена классов пишут латиницей, без пробелов, начиная с букв, а не цифр или спецсимволов. Такой способ определения стилей — надёжен и точен. В дальнейшем рекомендуем задавать стили для классов и свести к минимуму использование имён элементов в качестве селекторов.

===== Приятное и полезное

В предыдущей версии этого курса студенты жаловались на один нюанс. Сейчас после каждого обновления результата нужно проскролить header, чтобы увидеть изменения. Это отвлекает, раздражает и усложняет восприятие. Вот бы этот header убрать на время, но не удалять. Так можно?

Можно. Комментарии в коде нужны не только для информативных заметок, но и для временного отключения строк кода без их удаления. В каждом языке комментарии оформляются по-своему.

<!-- в HTML-коде комментарий окружён такими символами -->
<!-- <p>невидимый пользователю абзац</p> --> 

/* в CSS — такими */
/* p {
    color: white;
} */ 

Браузер игнорирует и не реализует написанное внутри комментариев.

===== Типографика под контролем
Отступы вокруг заголовка карточки вы не заказывали. Браузер установил их без вашего ведома.
Верстальщик берёт контроль за поведением элементов на себя. Предстоит сбросить все «заводские настройки» браузера, а затем задать стили для текстов внутри карточек.

Для сброса размеров текста воспользуйтесь комбинацией font-size: 100%; font-weight: normal. Первое свойство установит единый для всех элементов размер шрифта. Второе свойство задаст толщину шрифта со значением normal.

===== Поток и блочная модель

Порядок расположения элементов на странице называют поток. Браузер читает код файла сверху вниз и так же отрисовывает страницу. Поэтому говорят, что элементы следуют друг за другом в потоке.

Знакомые вам div, section, header, h1–h6 и p, располагаясь в потоке, по умолчанию занимают всю ширину своего родителя. Такие элементы называются блочными.

Модель любого блочного элемента:
- содержимое с размерами width и height;
- внешние отступы, они же поля: margin;
- внутренние отступы padding;
- границы, которые в коде вы пока не встречали, но ещё встретите.

Изображения - не блочные элементы, и под 100% ширины родительского элемента не подстраиваются. Картинки уже имеют размер и отрисовываются такими, какие они есть. В данном случае изображения больше div и вышли за их пределы.

===== Внешние и внутренние отступы

Внешний отступ — это пространство вокруг границы элемента снаружи. Задаётся свойствами группы margin, с ними вы уже имели дело.
В отличие от внешних отступов, внутренние — padding — смотрят внутрь элемента и создают свободное пространство между границей и содержимым.
Слово padding взято у портных и означает подплечник, подушечку между тканью пиджака и плечом. По аналогии: человек в пиджаке — это элемент, сам пиджак — видимая граница, тело под пиджаком — это контент. Чем больше padding, тем крупнее силуэт при том же объёме контента.
Для разных сторон внутренние отступы указываются, как у margin.

===== Короткая запись свойств

Устанавливать отступы для одного элемента с разных сторон можно короче. CSS позволяет записывать свойство в одну строку без уточнений стороны.

/* направление расстановки — по часовой стрелке, начиная сверху */

/* 4 значения */
/* для каждой стороны – своё значение */
padding: 20px 15px 30px 15px;

/* 3 значения */
/* верх — 10px, по бокам — 20px, низ — 30px */
padding: 10px 20px 30px;

/* 2 значения */
/* верх и низ — 10px, по бокам — 20px */
padding: 10px 20px;

/* 1 значение */
/* 10px со всех сторон */
padding: 10px;

Краткость решения подчеркивает его красоту. Сокращайте и оптимизируйте тривиальный, повторяющийся код.

===== Границы

Граница элемента находится между его margin и padding. В стилях границы определяют свойствами группы border:

border-color: #000; /* цвет границы */
border-width: 1px; /* толщина границы в px */
border-style: solid; /* начертание границы (см. картинку) */ 

Опять же — вместо написания трёх свойств по отдельности, разработчики применяют краткую форму. Значения color, width и style указывают внутри одного свойства через пробел:

/* непрерывная граница черного цвета толщиной 3px */
border: 3px solid #000; 

Кстати, граница тоже увеличивает элемент - он станет больше на указанное px с каждой стороны.

===== Внешний и внутренний фокус элемента

Обратите внимание на смысловую нестыковку. Ранее вы указали ширину 350px для карточки — как на макете. Но после манипуляций с внутренними отступами и границей, которые увеличили элемент, его ширина уже не та.

Выход есть. Например, брать калькулятор и высчитывать, насколько уменьшить значение width для класса card, чтобы в сумме с отступами и границами вышло 350.

Долго, сложно и чревато ошибками. Чтобы не считать вручную, есть свойство box-sizing — оно определяет поведение границ и внутренних отступов. По умолчанию для всех элементов действует правило box-sizing: content-box, границы и внутренний отступ расширяют элемент.

Установив для box-sizing значение border-box, вы измените фокус элемента: границы и внутренний отступ отрисуются внутрь. Общая ширина будет равна значению width. Довольно интуитивное поведение, поэтому нормальная практика — задать его сразу для всех элементов на странице.

Чтобы не печатать box-sizing вручную для всех элементов — познакомьтесь с селектором *. Он передаёт свойства напрямую каждому элементу на странице. Так как * очень общий селектор, создайте правило * { } сразу после сброса стилей, перед body { }. Не злоупотребляйте с этим, поскольку элементов много, браузеру придется работать с каждым из них.

===== Блочные + строчные

Кроме блочных элементов, в HTML есть строчные. Например, ссылки.

Блочный элемент занимает по умолчанию всю ширину родительского элемента.

Строчные элементы занимают ровно столько места, сколько контента в них содержится. Если они идут подряд, то по умолчанию все расположены на одной строке. Им невозможно задать ширину или высоту — они игнорируют указание размеров через стили.

Что делать, когда блоки с определенными размерами должны следовать друг за другом по горизонтали и не занимать всю строку? Можно задать элементам комбинированный тип — блочно-строчный. С одной стороны, они не занимают собой всю горизонталь, с другой, восприимчивы к указанию размеров через CSS. Например, так ведут себя элементы img.

Переопределяется тип свойством display:

/* display по-английски «отображение» */
display: block; /* сделает элемент блочным */
display: inline; /* сделает элемент строчным */
display: inline-block; /* сделает элемент блочно-строчным */ 

Благодаря работе с display становится возможной сетка элементов из текста второй карточки.

И строчные, и блочно-строчные элементы ведут себя как слова в предложении. А между словами стоят пробелы, ширина которых зависит от размера шрифта.

Поэтому карточки встают в строку, но не вплотную, хотя отступов между ними вы не задавали. Уберите непредвиденный зазор — присвойте родительскому элементу section класс content и задайте ему свойство font-size: 0.

Селектор .content { } рекомендуем разместить под .overlay { } и перед .card { }.
Это необязательно, ведь код работает и так. Но если у вас будет от 200-300 строк кода, то размещать селекторы где попало — плохой тон; придётся тратить массу времени на поиски нужной строчки.
Гораздо лучше держать стили для одного компонента рядом. По принципу «от общего — к частному», когда правила для дочерних элементов лежат ниже правил для родительских.

===== Расположение элементов по центру: margin: auto;

Напомним, карточки — блочные элементы, и поэтому занимают всю родительскую ширину даже несмотря на установленное width: 350px. Теперь мысленный эксперимент: как бы вы разместили карточки посередине занятой ими строки?

Свойство text-align не поможет — оно действует только на текст. Можно на глаз задать количество пикселей для margin-left первой карточки, пока правила не окажутся в центре. Но такой способ сработает только на вашем компьютере, а для экрана другого размера потребуется другое число пикселей.

С центрированием блочных элементов работает особое значение auto. Оно автоматически устанавливает максимально возможный отступ по горизонтали. Если задать свойствам margin-left и margin-right значение auto, получатся максимальные отступы с обеих сторон, и элемент встанет по центру своего родителя.

===== Несколько классов

Несколько классов пишут внутри значения одного атрибута class через пробел:

<div class="first second"></div>
<!-- у элемента есть и класс first, и класс second --> 

Например, общие свойства можно задать правилом для класса text, а уникальные — индивидуальным классом special-text.
HTML
<p class="text">Композиция дня:</p>
<p class="text special-text">Bonobo, Rhye — Break Apart</p> 
CSS
.text {
  font-size: 20px;
}

.special-text {
    font-size: 32px;
    color: #FEEB78;
} 

Через пробел можно задавать и два, и три, и четыре класса. Можно даже пять. Или шесть. Ну, вы поняли.

===== Тени

Тень — полезный инструмент дизайна. За её создание отвечает свойство box-shadow.

Свойство передаёт браузеру информацию, с какой стороны относительно элемента следует нарисовать тень, сделать её побольше или поменьше, и каким цветом. В коде это выглядит так:

div {
  box-shadow: -2px 2px 5px #FD6969;
  /* сдвинута на 2px влево, на 2px вниз */
  /* радиус размытия — 5px */
  /* цвет красноватый, #FD6969 */
} 

Последовательность значений, которые описывают тень:
- горизонтальный сдвиг (отрицательное значение помещает тень левее элемента, положительное — правее);
- вертикальный сдвиг (отрицательное значение помещает тень выше элемента, положительное — ниже);
- радиус размытия (чем значение больше, тем тень шире и бледней);
- цвет (задаётся так же, как цвет текста или фона).

Иногда тень не нужно сдвигать, достаточно только размытия. В этом случае указывают, что первые два значения равны 0.

Тень можно создавать не только для границ элемента, но и для текста. В этом случае используют свойство text-shadow. Оно работает аналогично.

===== Подвал сайта
Если верх веб-страницы называют «шапкой», то низ — это «подвал» сайта. Обычно он, как титры, содержит сопутствующую информацию: контакты, адреса, ссылки на социальные сети и другие страницы сайта.

Для создания подвала в HTML существует специальный элемент footer. Он, как div, header или section, создаёт пустую коробку.

===== Центрировать по вертикали

Вы уже сталкивались с этим, когда нужно было центрировать надпись «ЧЕТЫРЕ ПРАВИЛА ВЁРСТКИ» по вертикали. Тогда вам пришлось устанавливать внутренний отступ в пикселях, чтобы подвинуть текст в нужное место.

Это простой способ, только он не всегда работает. Но значение 100px на маленьком устройстве — это уже треть экрана, а на большом мониторе — почти незаметно. Поэтому не подгоняйте пиксели только под свой экран, подумайте и о посетителях вашего сайта.

И всё-таки: уже всерьёз планируют полёт на Марс, а в вебе до сих пор нет способа поставить элемент по центру автоматически?

Способ есть. Для уже изученного свойства display помимо block, inline и inline-block есть особое значение flex:

display: flex;
/* *flex* переводится как «гибкий» */ 

Элемент с таким свойством становится flex-элементом и — как супергерой — получает сверхспособности. Например, внутри него margin: auto работает не только по горизонтали! Невероятно, но это так. Чтобы запомнить, решите задачу центрирования для подвала.

Родительскому элементу display: flex, дочернему margin: auto;

/* PS >
О полном спектре возможностей *flex* мы рассказываем в курсе профессиональной вёрстки. */ 